<!DOCTYPE html>
<html lang="zh">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>zookeeper基础 | Bitree.club</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Wei Hao">
  <meta name="keywords" content="java,bigData,hive,hbase,kafka,spark">
  <meta name="description" content="��¼�ɳ�">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div class="single">

<div id="page">
<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/post_cover.jpeg)" data-stellar-background-ratio="0.5">
  <div class="overlay">
  <div class="page-title">
    <div class="avatar"><a href="/"><img src="/images/avatar.jpeg"></a></div>
    <span>2020-04-08</span>
    <h2>zookeeper基础</h2>
    <div class="tags"><i class="fa fa-tag"></i><a class="tag-link" href="/tags/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E3%80%91/" rel="tag">【大数据入门系列】</a></div>
    <div class="social-links">
</div></div>
</div>
</div>

<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <h1 id="Zookeeper简介"><a href="#Zookeeper简介" class="headerlink" title="Zookeeper简介"></a>Zookeeper简介</h1><p>官网地址：<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a></p>
<p>ZooKeeper是开源的<strong>分布式协调服务框架，</strong>将复杂且容易出错的分布式一致性服务封装起来，构建一系列简单的原语（<em>原子语言，不可分割，不可中断，是操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程</em>）和易用的api接口，分布式应用程序可以通过zookeeper实现同步、配置管理、组和命名服务、集群管理等等。</p>
<h2 id="zookeeper设计目标"><a href="#zookeeper设计目标" class="headerlink" title="zookeeper设计目标"></a><strong>zookeeper设计目标</strong></h2><p>Zookeeper 致力于为那些高吞吐的大型分布式系统提供一个高性能、高可用、且具有严格顺序访问控制能力的分布式协调服务。它具有以下目标：</p>
<h3 id="1-简单的数据模型"><a href="#1-简单的数据模型" class="headerlink" title="1.简单的数据模型"></a>1.简单的数据模型</h3><p>ZooKeeper允许分布式进程通过共享的<strong>层级</strong>命名空间相互协调，该命名空间的结构与标准文件系统类似。名称空间由数据寄存器组成–在ZooKeeper中称为znodes，与文件和目录类似。</p>
<ul>
<li>zookeeper是一个树状结构–znode树(<em>维系在内存中，高吞吐量和低延迟</em>)</li>
<li>每一个节点称为znode节点，且每一个znode节点必须存储数据</li>
<li>根节点是/ ，zookeeper所有的操作都必须以根节点为基准进行计算。</li>
<li>任意一个节点的路径都是唯一的</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-0c70350d535cd1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="2-构建zookeeper集群"><a href="#2-构建zookeeper集群" class="headerlink" title="2.构建zookeeper集群"></a><strong>2.构建zookeeper集群</strong></h3><p>  可以由多个zookeeper服务（通常是<strong>奇数</strong>个）构成zookeeper集群，与它协调的分布式进程一样，ZooKeeper本身也可以在集群中进行复制。集群中每台机器都会单独在<strong>内存中（*</strong>拥有高吞吐量和低延迟数<strong>*）</strong>维护自身的状态，并且每台机器之间都保持着通讯，zookeeper服务之间必须彼此了解它们在内存中的状态，以及持久性存储(硬盘存储)中的事务日志和快照。只要集群中有<strong>半数（过半性）</strong>机器能够正常工作，那么整个集群就可以正常提供服务，故其可靠性极高。</p>
<p>客户端连接到单个ZK服务，客户端维护TCP连接，通过该连接发送请求，获取响应，获取监视事件以及发送心跳。如果与ZK服务的TCP连接中断，则客户端将连接到其他可用ZK服务。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-4dc7d275318d73ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="3-顺序访问"><a href="#3-顺序访问" class="headerlink" title="3.顺序访问"></a><strong>3.顺序访问</strong></h3><p>对于来自客户端的每个更新请求，Zookeeper 都会分配一个全局唯一的递增 ID，这个 ID 反映了所有事务请求的先后顺序。保证了分布式系统的<strong>顺序一致性：</strong>从同一个客户端发起的事务请求，最终将会严格按照其<strong>发起顺序</strong>被应用到ZooKeeper中。</p>
<h3 id="4-基于事务的高性能、高可用"><a href="#4-基于事务的高性能、高可用" class="headerlink" title="4.基于事务的高性能、高可用"></a>4.基于事务的高性能、高可用</h3><p>ZooKeeper 将数据存全量储在内存中以保持高性能，并通过服务集群来实现高可用，由于 Zookeeper 的所有更新和删除都是基于事务的，其在读多写少的应用场景中有着很高的性能表现。</p>
<ul>
<li><strong>原子性：</strong>所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</li>
<li><strong>单一视图</strong>：无论客户端连接的是哪个ZooKeeper服务器，其看到的<strong>服务端数据模型</strong>都是<strong>一致</strong>的。</li>
<li><strong>可靠性</strong>：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</li>
<li><strong>实时性</strong>：通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</li>
</ul>
<h2 id="Zookeeper-集群搭建"><a href="#Zookeeper-集群搭建" class="headerlink" title="Zookeeper 集群搭建"></a><strong>Zookeeper 集群搭建</strong></h2><p>参考文章：<a href="https://blog.51cto.com/nileader/795230" target="_blank" rel="noopener">https://blog.51cto.com/nileader/795230</a></p>
<p>作者：@<a href="http://weibo.com/nileader" target="_blank" rel="noopener">ni掌柜</a> nileader@gmail.com</p>
<h2 id="Zookeeper集群中的角色以及工作流程"><a href="#Zookeeper集群中的角色以及工作流程" class="headerlink" title="Zookeeper集群中的角色以及工作流程"></a><strong>Zookeeper集群中的角色以及工作流程</strong></h2><h4 id="1-Leader-领导者"><a href="#1-Leader-领导者" class="headerlink" title="1.Leader(领导者)"></a><strong>1.Leader(领导者)</strong></h4><ol>
<li>由集群选举所产生,接受client请求</li>
<li>恢复数据</li>
<li>负责更新系统状态</li>
<li>接收其他server转发的<strong>写</strong>请求，维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型。Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。 </li>
</ol>
<ul>
<li>PING 消息是指Learner的心跳信息；</li>
<li>REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；</li>
<li>ACK消息是 Follower的对提议的回复，超过半数的Follower通过，则commit该提议；</li>
<li>REVALIDATE消息是用来延长SESSION有效时间。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-3e1ef92e5053b977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h4 id="2-Learner-学习者）"><a href="#2-Learner-学习者）" class="headerlink" title="2. Learner(学习者）"></a><strong>2. Learner(学习者）</strong></h4><h5 id="Follower-–-跟随者"><a href="#Follower-–-跟随者" class="headerlink" title="Follower  – 跟随者"></a>Follower  – 跟随者</h5><ol>
<li>为客户端提供读写服务（读请求直接由该Follower的内存数据库直接响应，写请求转发给Leader）返回client结果 </li>
<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）</li>
<li>接收Leader消息并进行处理</li>
<li>定期向 Leader 汇报自己的节点状态。同时也参与写操作“过半写成功”的策略和 Leader 的选举</li>
</ol>
<p><strong>Follower的消息循环处理如下几种来自Leader的消息：</strong> </p>
<ul>
<li>PING消息： 心跳消息； </li>
<li>PROPOSAL消息：Leader发起的提案，要求Follower投票； </li>
<li>COMMIT消息：服务器端最新一次提案的信息； </li>
<li>UPTODATE消息：表明同步完成； </li>
<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息； </li>
<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-f2d4e2536bcea1ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h5 id="Observer–观察者"><a href="#Observer–观察者" class="headerlink" title="Observer–观察者"></a>Observer–观察者</h5><ol>
<li>为客户端提供读写服务（读请求直接由该Follower的内存数据库直接响应，写请求转发给Leader） </li>
<li>定期向 Leader 汇报自己的节点状态。<strong>不参与</strong>写操作“过半写成功”的策略和 Leader 的选举；因此Observer可以在<strong>不影响写性能</strong>的情况下<strong>提升</strong>集群的<strong>读性能</strong>。</li>
</ol>
<h4 id="3-Client–客户端"><a href="#3-Client–客户端" class="headerlink" title="3.Client–客户端"></a>3.Client–客户端</h4><ol>
<li>发起读写请求，接收server端的响应。</li>
</ol>
<h4 id="当前节点角色状态查询："><a href="#当前节点角色状态查询：" class="headerlink" title="当前节点角色状态查询："></a><strong>当前节点角色状态查询：</strong></h4><p>在装有ZooKeeper的机器的终端执行 <strong>zookeeper-server status</strong> 可以看当前节点的ZooKeeper是什么角色（Leader or Follower or Observer）。一个ZooKeeper集群同一时刻只会有一个Leader，其他都是Follower或Observer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-4e7c3fb85f22e660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-081e4b47eb919599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-58776cd147203514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h2 id="Zookeeper数据节点类型和状态"><a href="#Zookeeper数据节点类型和状态" class="headerlink" title="Zookeeper数据节点类型和状态"></a><strong>Zookeeper数据节点类型和状态</strong></h2><p>『节点』指的是组成集群的每一台机器。而ZooKeeper中的数据节点是指数据模型中的数据单元，称为ZNode。ZooKeeper将所有数据存储在内存中，数据模型是一棵树（ZNode Tree），由斜杠（/）进行分割的路径，就是一个ZNode，如/hbase/master,其中hbase和master都是ZNode。每个ZNode上都会保存自己的数据内容，同时会保存一系列属性信息。在ZooKeeper中，ZNode可以分为持久节点和临时节点两类。</p>
<ol>
<li>持久节点（PERSISTENT）: 默认创建持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。</li>
<li>持久顺序节点（PERSISTENT_SEQUENTIAL）: 基本特性与持久节点一致，创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名，这种节点会根据当前已存在的节点数自动加 1</li>
<li>临时节点（EPHEMERAL）: 在客户端退出之后就自动删除</li>
<li>临时顺序节点（EPHEMERAL_SEQUENTIAL）: 临时自动编号节点，在客户端退出之后就自动删除</li>
</ol>
<h2 id="Zookeeper-节点数据操作流程"><a href="#Zookeeper-节点数据操作流程" class="headerlink" title="Zookeeper 节点数据操作流程"></a><strong>Zookeeper 节点数据操作流程</strong></h2><p><img src="https://upload-images.jianshu.io/upload_images/20723660-614c87f5d80ac53c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<ol>
<li>在Client向Follwer发出一个写的请求</li>
<li>Follwer把请求发送给Leader</li>
<li>Leader接收到以后开始发起投票并通知Follwer进行投票</li>
<li>Follwer把投票结果发送给Leader</li>
<li>Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader，然后commit;</li>
<li>Follwer把请求结果返回给Client</li>
</ol>
<h2 id="Zookeeper-客户端命令"><a href="#Zookeeper-客户端命令" class="headerlink" title="Zookeeper 客户端命令"></a><strong>Zookeeper 客户端命令</strong></h2><p><strong>zookeeper-cli 进行连接， 输入help可以查看zookeeper客户端中支持的命令</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-c07b8f86e1f9cac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><strong>1. ls /节点名称</strong> </p>
<p><strong>查看节点目录</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-b72e46067ceb416b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>ls /   查看根节点下有zookeeper 、ngdata、hbase 、solr 节点</p>
<p><strong>2. create /节点名称  值</strong>              </p>
<p> <strong>创建节点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-907f293f9ebd47e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>   create  /lijiaxin “good_girl”   在根节点下创建子节点lijiaxin并且赋值为good_girl </p>
<p>  注意 create /lijiaxin “good girl” 会报错，提示如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-03a74e080107cf31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>这是因为 ZooKeeper有一个分层的名字空间，跟分布式文件系统很相似。唯一的不同是，名字空间中的每个节点都可以有关联的数据和子节点。这就像一个允许文件也是目录的文件系统。节点路径总是表达为规则的、斜杠分隔的绝对路径，不存在相对路径。路径可以使用任何Unicode字符，但是需要遵循下列限制：不能使用空字符(?)。（这在C绑定中会导致问题） 因为不能正确显示，或者容易弄混淆，不能使用这些字符：\ - \和\ - ?。不允许使用这些字符：? - uF8FFF、? - uFFFF、\uXFFFE - \uXFFFF(X是1到E之间的一个数字)、? - ?。可以使用小数点，但是不能单独使用.和..来指示路径中的节点，因为ZooKeeper不使用相对路径。/a/b/./c或者/a/b/../c是无效的。 记号zookeeper是保留的。 set 同理</p>
<p><strong>3. get /节点名称</strong>   </p>
<p><strong>获取节点的信息</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-d60ecded7abe61f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>   get /lijiaxin  获取节点/lijiaxin的相关信息</p>
<p>每个 ZNode 节点在存储数据的同时，都会维护一个叫做 Stat 的数据结构，里面存储了关于该节点的全部状态信息。如下：</p>
<table>
<thead>
<tr>
<th>状态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>czxid</td>
<td>数据节点创建时的事务 ID</td>
</tr>
<tr>
<td>ctime</td>
<td>数据节点创建时的时间</td>
</tr>
<tr>
<td>mzxid</td>
<td>数据节点最后一次更新时的事务 ID</td>
</tr>
<tr>
<td>mtime</td>
<td>数据节点最后一次更新时的时间</td>
</tr>
<tr>
<td>pzxid</td>
<td>数据节点的子节点最后一次被修改时的事务 ID</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点的更改次数,当znode的子节点变化时，cversion的值会加1</td>
</tr>
<tr>
<td>dataversion</td>
<td>节点数据的更改次数,每当对节点进行set操作时，dataversion的值就会加1</td>
</tr>
<tr>
<td>aversion</td>
<td>节点的 ACL 的更改次数</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据内容的长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>数据节点当前的子节点个数</td>
</tr>
</tbody></table>
<hr>
<p><strong>4. set  /节点名称  值</strong></p>
<p><strong>更改节点的值</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-a3c86beeae519335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>set /lijiaxin “good_women”  将lijiaxin的数据更新为good_women </p>
<p><strong>5. delete /节点名称</strong>  </p>
<p><strong>删除子节点要求这个节点中没有子节点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-583701c865c14612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>在/lijiaixn姐殿下创建/weihao 节点，直接删除/lijiaxin节点会提示节点不为空无法删除。delete只能删除没有子节点的节点</p>
<p><strong>6. rmr /节点名称</strong></p>
<p><strong>删除节点及其子节点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-418bb31f656383fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>删除/lijiaxin节点及其子节点</p>
<p><strong>7. quit</strong> </p>
<p><strong>退出客户端</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-20f3680c874ea38f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>退出客户端，session会话关闭</p>
<p><strong>8. creaet  /节点名称  值</strong></p>
<p><strong>创建持久节点（默认） 属性值如下：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-5eae84e1576a4482.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>create /weihao ”good_man“ 创建持久节点/weihao, ephemeralowner =0x0 的是持久化节点</p>
<p><strong>9.create -e /节点名称  值</strong></p>
<p> <strong>表示创建临时节点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-d00642a1234ff220.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>创建临时节点/weihao1 ephemeralOwner = 0x3714514f1c00582 该属性是临时节点的事务ID </p>
<p><strong>quit 退出后再次登录查看，会发现该临时节点已删除</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-17637567e3291f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>临时节点/weihao1已删除</p>
<p><strong>10. create -s  /节点名称  值</strong></p>
<p><strong>创建持久顺序节点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-06ff545bb87bc4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>创建持久顺序节点/weihao1和/weihao2， 创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名，这种节点会根据当前已存在的节点数自动加 1 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-c9103febfda69d0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>ephemeralOwner = 0x0 说明该节点是持久节点</p>
<p><strong>11.create -e -s /节点名称 值</strong> </p>
<p><strong>创建临时顺序节点</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-7f55e03d5384202b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>创建临时顺序节点/weihao3和/weihao4， 创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名， 这种节点会根据当前已存在的节点数自动加 1 ,ephemeralOwner = 0x1714823254503bb说明该节点为临时节点</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-559cb4453d9b9190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>quit退出重新登录后发现该临时顺序节点已被删除</p>
<h2 id="Zookeeper-Session"><a href="#Zookeeper-Session" class="headerlink" title="Zookeeper  Session"></a><strong>Zookeeper  Session</strong></h2><p>Session(会话)是ZooKeeper中的会话实体，代表了一个客户端会话，其包含4个属性。</p>
<ol>
<li><strong>SESSIONID</strong>:唯一标识一个会话，每个客户端创建会话时，服务器都会为其分配一个全局唯一的SessionID</li>
<li><strong>TimeOut</strong>:会话超时时间，在客户端创建TCP连接时指定</li>
<li><strong>TickTime</strong>:Zookeeper自定义的时间单位，超时时间一般为2<em>TickTime~~20</em>TickTime</li>
<li><strong>IsClosing</strong>:客户端重新成功连接服务器后，客户端当前状态</li>
</ol>
<p>Zookeeper客户端启动时会与服务器建立一个TCP长连接。从连接指令发出后，客户端Session的生命周期就开始了，在整个生命周期内会切换不同的会话状态。</p>
<ul>
<li>CONNECTING客户端开始创建Zookeeper对象时，客户端当前状态</li>
<li><strong>CONNECTED</strong>:客户端成功连接服务器后，客户端当前状态</li>
<li><strong>RECONNECTING</strong>:由于网络抖动等原因导致客户端与服务器闪断，客户端会尝试重连，客户端当前状态</li>
<li><strong>RECONNECTED</strong>:客户端重新成功连接服务器后，客户端当前状态</li>
<li><strong>CLOSE</strong>: 当会话过期时，客户端当前状态</li>
</ul>
<p>通过该TCP连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向服务器发送请求并接受响应，还能够接收来自服务器的 watch 事件通知，便于实时响应某些操作。</p>
<h2 id="Zookeeper-Watcher"><a href="#Zookeeper-Watcher" class="headerlink" title="Zookeeper Watcher"></a><strong>Zookeeper Watcher</strong></h2><p>​    Zookeeper提供了分布式数据发布/订阅功能，一个典型的发布订阅模型系统定义了一种一对多的订阅关系，能让订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</p>
<p>​    Zookeeper中引入了watcher机制来实现这种分布式的通知功能。Zookeeper允许客户端向服务端注册一个Watcher监听，当服务端的一些事件触发了这个watcher，那么就会向指定客户端发送一个事件通知来实现分布式通知功能。</p>
<p>​    触发事件总类很多,如：节点创建，节点删除，节点改变，子节点改变等等。总的来说可以概括为Watcher为以下三个过程：客户端向服务端注册watcher、服务端事件发生触发watcher、客户端回调watcher得到触发事件情况。</p>
<p><strong>Watcher机制特点</strong></p>
<h3 id="1-一次性触发"><a href="#1-一次性触发" class="headerlink" title="1.一次性触发"></a><strong>1.一次性触发</strong></h3><p>事件发生触发监听，一个Watcher Event就会被发送到设置监听的客户端、这种效果是一次性的，后面再次发生同样的事件，不会再次触发。</p>
<h3 id="2-事件封装"><a href="#2-事件封装" class="headerlink" title="2.事件封装"></a><strong>2.事件封装</strong></h3><p>zookeeper使用watchdEvent 对象来封装服务端事件并传递,WatchedEvent包含了每一个事件的三个基本属性；</p>
<p>通知状态（keeperState）,事件类型（EventType) 和节点路径（path）</p>
<h3 id="3-event异步发送"><a href="#3-event异步发送" class="headerlink" title="3.event异步发送"></a><strong>3.event异步发送</strong></h3><p>watcher的通知事件从服务端到客户端是异步的</p>
<h3 id="4-先注册再触发"><a href="#4-先注册再触发" class="headerlink" title="4.先注册再触发"></a><strong>4.先注册再触发</strong></h3><p>zookeeper中的watcher机制，必须客户端先去服务端测试监听，这样事件发送才会触发监听，通知给客户端。</p>
<p><strong>shell 客户端设置监听</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-28eb95aaa88c549e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>创建/lijiaxin 节点， get /lijiaxin watch  监听lijiaxin节点，注册监听事件</p>
<p>​        在另一个客户端修改/lijiaixin节点就会触发watcher监听</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-b50c56d35a7e7a30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>在另一个zookeeper节点修改/lijiaxin的值,触发监听事件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-8fe22d90f4436c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>客户端监听到了变化，/lijiaxin节点数据改变。</p>
<p>​        再次在另一个Zookeeper节点修改znode节点/lijiaxin的值</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-8f9aa450dc2894f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>修改/lijiaxin 为good_womens</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-843103409c107410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>此时会发现监听没有触发，说明监听只触发一次</p>
<h2 id="Zookeeper的ACL–权限控制"><a href="#Zookeeper的ACL–权限控制" class="headerlink" title="Zookeeper的ACL–权限控制"></a><strong>Zookeeper的ACL–权限控制</strong></h2><p>Zookeeper 采用 ACL(Access Control Lists) 策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</p>
<p><strong>它定义了如下5种权限：</strong></p>
<ol>
<li><strong>CREATE：</strong>允许创建子节点</li>
<li><strong>READ：</strong>允许从节点获取数据并列出其子节点</li>
<li><strong>WRITE：</strong>允许为节点设置数据</li>
<li><strong>DELETE：</strong>允许删除子节点</li>
<li><strong>ADMIN：</strong>允许为节点设置权限。 </li>
</ol>
<p><strong>使用zkCli时，ACL的格式由::三段组成。</strong></p>
<p>schema：可以取下列值：world, auth, digest, host/ip</p>
<p>id： 标识身份，值依赖于schema做解析。</p>
<p>acl：就是权限：c、d 、w、r、a分别表示create, delete,write,read, admin</p>
<p>注意：zookeeper对权限的控制是znode级别的，不具有继承性，即子节点不继承父节点的权限。这种设计在使用上还是有缺陷的，因为很多场景下，我们还是会把相关资源组织一下，放在同一个路径下面，这样就会有对一个路径统一授权的需求。</p>
<p><strong>1.schema world</strong></p>
<p>这是默认方式，表示没有认证。当创建一个新的节点(znode)，而又没有设置任何权限时，就是这个值，例如： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-6858ca229c5765ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>世界上所有人都有权限（默认），任何人都能访问</p>
<p><strong>等价于:</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-cc3df12bac7221d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>setAcl /znode world:anyone:cdrwa 任何人都能访问该节点</p>
<p><strong>2.schema auth</strong></p>
<p>这种授权不针对任何特定ID，而是对所有已经添加认证的用户，换句话说，就是对所有已经通过认证的用户授权。 </p>
<p><strong>格式：</strong></p>
<p><strong>addauth digest ：  添加认证用户</strong></p>
<p><strong>setAcl  auth::   对认证用户进行授权</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-92b147587f1a88c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>必须要先添加认证用户，否则会失败。如上所示：</p>
<p>setAcl命令中的id域是被忽略的，可以填任意值，或者空串，例如：`setAcl <path> auth::crdwa。因为这个域是忽略的，会把所有已经添加的认证用户都加进来。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-69d5767027cea48b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>如图：我们只设置了auth:weihao，但是查看acl权限的时候发现上面添加的用户都有权限，根据前面的说法，这个id值是被忽略的，写任何值，甚至空值也得到一样的结果。我们看到最后getAcl查询出来的结果包含所有前面添加的三个认证用户。</p>
<p>**3.schema digest</p>
<p>**</p>
<p>这就是最普通的用户名:密码的验证方式，在一般业务系统中最常用。格式如下：</p>
<p>格式：<strong>setAcl   digest:::</strong></p>
<p>和schema auth相比，有两点不同：</p>
<ol>
<li>不需要预先添加认证用户(但是在zkCli访问的时候，肯定还是要添加认证用户的)。</li>
<li>密码是经过sha1及base64处理的密文。</li>
</ol>
<p>密码可以通过如下shell的方式生成：</p>
<p>echo-n<user>:<password>|openssl dgst-binary-sha1|openssl base64</p>
<p>例如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-8dfba8b18287d4e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>输出的+w4Bol0tkQ0bdBTE1Hc8kqZc7ec=就是传递给setAcl使用的id串。</p>
<p>注意，只有通过zkCli.sh设置digest的ACL时id才需要密文，而通过zookeeper的客户端设置digest的ACL时对应的auth数据是明文。这个属于编码实现的问题了。</p>
<p>和auth比较，digest有如下特性：</p>
<ul>
<li>setAcl不需要事先添加认证用户</li>
<li>授权是针对单个特定用户</li>
</ul>
<p>setAcl使用的密码不是明文，是sha1摘要值，无法反推出用户密码内容。</p>
<p><strong>4.schema host/ip</strong></p>
<p><strong>格式:setAcl /znode ip:xxx.xxx.xxx.xxx:</strong></p>
<p>就是客户机地址，或者是主机名、或者是IP地址。</p>
<p>主机名可以是单个主机名，也可以是域名。IP可以是单个IP地址，也可以是IP地址段，比如ip:192.168.1.0/16。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20723660-30ad296f10a4e6cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>参考：</p>
<p>作者：CodingCode  链接：<a href="https://www.jianshu.com/p/392248ab27f4" target="_blank" rel="noopener">https://www.jianshu.com/p/392248ab27f4</a> 来源：简书</p>
<p>作者：Jeffbond   链接：<a href="https://www.jianshu.com/p/84ad63127cd1" target="_blank" rel="noopener">https://www.jianshu.com/p/84ad63127cd1</a> 来源：简书</p>
<p>作者：<a href="https://blog.51cto.com/nileader/795230" target="_blank" rel="noopener">@</a><a href="http://weibo.com/nileader" target="_blank" rel="noopener">ni掌柜</a><a href="mailto:nileader@gmail.com">nileader@gmail.com</a> 链接：<a href="https://blog.51cto.com/nileader/795230" target="_blank" rel="noopener">https://blog.51cto.com/nileader/795230</a></p>
<p>作者：<a href="https://me.csdn.net/gs80140" target="_blank" rel="noopener">gs80140</a> 链接：<a href="https://blog.csdn.net/gs80140/article/details/51496925" target="_blank" rel="noopener">https://blog.csdn.net/gs80140/article/details/51496925</a></p>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover prev lx-cover-sm" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/footer-l.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="/2020/04/08/zookeeper%E5%85%A5%E9%97%A8api/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>zookeep...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover next lx-cover-sm" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/footer-r.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="#">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>没有更早的文章</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>

</div>

<footer>
  <div>
  Copyright &copy; 2019.<a href="/">Bitree.club</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="Wei Hao"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>Wei Hao</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>首页</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>归档</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>页面</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>友链</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
